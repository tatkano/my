import networkx as nx

# Create an empty graph
G = nx.Graph()

# Add nodes
for i in range(1, 6):
    G.add_node(i)
    i=i+1

# Add edges
G.add_edge(1, 2)
G.add_edge(2, 3)
G.add_edge(3, 4)
G.add_edge(4, 5)
G.add_edge(2, 5)
G.add_edge(4, 6)
G.add_edge(1, 5)

nx.draw_spring(G, with_labels = True) # здесь можно на примере нарисованного графа понять правильно ли дальше работает программа

INF = 10000 # задаем расстояние равное большому числу - аналог бесконечности, чтобы показать, что между вершинами нету прямой связи

A = [[0, 1, INF, INF, 1, INF], [1, 0, 1, INF, 1, INF], [INF, 1, 0, 1, INF, INF], [INF, INF, 1, 0, 1, 1], [1, 1, INF, 1, 0, INF], [INF, INF, INF, 1, INF, 0]]
#A = [[0, 1, 1], [1, 0, 1], [1, 1, 0]] - пробовала на треугольнике ABC, но в этой матрице нет смысла раздавать бесконечные расстояния, так как в ней все вершины связаны друг с другом

# дальше вывожу матрицу, которая конечно не слишком красиво и ровно выглядит, так как в ней есть значения цифр из 4 знаков

for i in range(len(A)): 
    for j in range(len(A[i])): 
        print(A[i][j], end=' ')
    print()
print()

N = 6

painted = [False]*N # массив,в который добавляются вершины по принципу проверили их или нет, значения имеют логический тип
dlina = [INF]*N # в этот массив добавляются длины кратчайших маршрутов
# первоначальные значения неизвестны, поэтому равны большим числам

nachalo = 0 # задаем начальную вершину, допустим первая
dlina[nachalo] = 0 # первоначальное расстояние от вершины до самой себя

B = nachalo # номер начальной вершины записывается в переменную B
minDlina = 0 # начальное значение кратчайшего расстояния

while minDlina < INF:
    painted[B] = True
 # проверяем можно ли уменьшить длину пути через вершину B, если длина по новому пути меньше, то переприсваиваем значение
    for j in range(N):
        if dlina[B]+A[B][j] < dlina[j]:
            dlina[j] = dlina[B] + A[B][j]
 # поиск следующей наиболее оптимальной, еще не выбранной вершины, где расстояние от заданной вершины минимально
    minDlina = 1e6  # берем еще большее число по сравнению с INF, например, 10**6 (если взять меньше, то программа долго отрабатывает)
    for j in range(N):
        if not painted[j] and dlina[j] < minDlina:
            minDlina = dlina[j]
            B = j

# вывод решения для вершины 1 на экран
for i in range(len(A)):
    print(f'Кратчайший путь из вершины 1 до вершины {i+1} равен {dlina[i]}')
print()

# и вот самое красивое решение, в результате которого заполняется матрица, где элементами являются кратчайшие расстояния между вершинами - алгоритм Флойда-Уоршелла
for k in range(N):
    for i in range(N):
        for j in range(N):
            if A[i][k]+A[k][j] < A[i][j]:
                A[i][j] = A[i][k]+A[k][j]

print(f'Матрица, содержащая кратчайшие расстояния между вершинами \n')

for i in range(len(A)): 
    for j in range(len(A[i])): 
        print(A[i][j], end=' ')
    print()
